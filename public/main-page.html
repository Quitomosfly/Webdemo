<!DOCTYPE html>
<html lang="en">
<head>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Reddit+Sans:wght@300;400;700&display=swap" rel="stylesheet">
    <title>Main Event Page</title>
    <style>
        body {
            font-family: 'Reddit Sans', sans-serif;
            background-color: #f8f8f8;
            margin: 0;
            padding: 0;
        }
        .navbar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px 30px;
            background-color: #ffffff;
            border-bottom: 2px solid pink;
            position: fixed;
            width: 100%;
            top: 0;
            left: 0;
            z-index: 1000;
        }
        .navbar .logo a {
            font-size: 28px;
            font-weight: bold;
            color: #333;
            text-decoration: none;
            transition: color 0.3s ease, transform 0.3s ease;
        }
        .navbar .logo a:hover {
            color: #198754;
            transform: scale(1.1);
        }
        .navbar .nav-links {
            display: flex;
            gap: 20px;
            padding-right: 30px; /* Add some right padding */
        }


        .navbar .nav-links a {
            text-decoration: none !important;
            color: black !important;
            font-size: 16px;
            padding: 10px 15px;
            display: inline-block;
            transition: color 0.3s ease, text-decoration 0.3s ease;
        }

        .navbar .nav-links a:visited {
            color: black !important;
        }
        .container {
            max-width: 900px;
            margin: auto;
            padding: 20px;
            text-align: center;
            margin-top: 80px;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            background: #fff;
            margin-top: 20px;
        }
        th, td {
            border: 1px solid #ccc;
            text-align: center;
            padding: 10px;
            cursor: pointer;
            user-select: none;
        }
        th {
            background-color: #f2f2f2;
        }
        td.selected {
            background-color: #28a745;
            color: white;
        }
        td.disabled {
            background-color: #ddd;
            cursor: not-allowed;
        }
        .button-container {
            margin: 20px 0;
        }
        .button {
            padding: 10px 20px;
            background-color: #007bff;
            color: white;
            border: none;
            cursor: pointer;
            font-size: 16px;
            border-radius: 5px;
        }
        .button:hover {
            background-color: #0056b3;
        }
        .hidden {
            display: none;
        }
        .time-slot.available {
            background-color: #ddd;  /* Green background */
            color: white;  /* Text color for visibility */
        }

        .time-slot.selected {
            background-color: #8BC34A;  /* Slightly lighter green for selected time slot */
            color: white;  /* Text color for visibility */
        }

        .time-slot.disabled {
            background-color: #4CAF50;  /* Grey out the disabled slots */
            cursor: not-allowed;     /* Change the cursor to indicate it's not interactive */
        }
        .time-slot.saved {
            background-color: #28a745;
            color: white;
        }

        .time-slot {
            /* Add other styles for the time slots here */
            padding: 10px;
            text-align: center;
            border: 1px solid #ddd;
        }

        .participant-tooltip {
            position: absolute;
            display: none;
            background: white;
            border: 1px solid #ccc;
            border-radius: 10px;
            padding: 8px 12px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            font-size: 14px;
            z-index: 1000;
            pointer-events: none;
        }

        .participant-tooltip .name-badge {
            display: inline-block;
            background-color: #e0f2fe;
            color: #0369a1;
            padding: 4px 8px;
            margin: 2px;
            border-radius: 999px;
            font-weight: 500;
        }

        #participantPanel {
            background-color: #f9fafb;
            padding: 16px;
            border-radius: 12px;
            border: 1px solid #e5e7eb;
        }

        #participantList > div:hover {
            background-color: #f1f5f9;
            border-radius: 8px;
            padding: 4px;
        }
    </style>
</head>
<body>
    <div class="navbar">
        <div class="logo">
            <a href="https://ctaf-q8o9.onrender.com/home.html">CTAF</a>
        </div>
        <div class="nav-links">
            <a href="https://ctaf-q8o9.onrender.com/home.html">Home</a>
            <a href="https://ctaf-q8o9.onrender.com/home.html#howItWorks">How It Works</a>
        </div>
    </div>

    <div class="container">
        <h1>Event Schedule</h1>
        <h2 id="eventName"></h2>
        <div class="button-container">
            <button class="button" onclick="askUserName()">Add Availability</button>
            <button id="saveButton" class="button hidden" onclick="saveAvailability()">Save Availability</button>
        </div>
        <div style="display: flex; gap: 2rem;">
            <!-- Schedule Grid Section -->
            <div style="flex: 1;">
              <h2 class="text-xl font-bold text-center">Schedule Grid</h2>
              <table id="scheduleTable" class="table-auto border border-collapse w-full mt-4">
                <!-- Table headers + time slots will be generated by JavaScript -->
              </table>
            </div>
          
            <!-- Participant Panel -->
            <div style="width: 250px;" id="participantPanel">
              <h2 class="text-xl font-bold mb-2">Responses</h2>
              <div id="participantList" class="space-y-2">
                <!-- Filled dynamically by JavaScript -->
              </div>
            </div>
        </div>
    </div>

        <!-- Username Input Modal -->
    <div id="nameModal" style="display:none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; 
    background: rgba(0, 0, 0, 0.5); z-index: 9999; justify-content: center; align-items: center;">
        <div style="background: white; padding: 30px; border-radius: 10px; text-align: center; max-width: 300px; width: 80%;">
            <h2 style="margin-bottom: 15px;">Enter Your Name</h2>
            <input id="userNameInput" type="text" placeholder="Your name" style="width: 100%; padding: 8px; margin-bottom: 15px; font-size: 16px;">
            <div>
                <button onclick="submitUserName()" style="padding: 8px 16px; background-color: #007bff; color: white; border: none; border-radius: 5px;">Submit</button>
            </div>
        </div>
    </div>

        <!-- Second Modal for Manual or EAF -->
    <div id="actionModal" style="display:none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; 
    background: rgba(0, 0, 0, 0.5); z-index: 9999; justify-content: center; align-items: center;">
        <div style="background: white; padding: 30px; border-radius: 10px; text-align: center; max-width: 300px; width: 80%;">
            <h2 style="margin-bottom: 15px;">Choose an Action</h2>
            <div>
                <button onclick="selectAction('Manual')" style="padding: 8px 16px; background-color: #007bff; color: white; border: none; border-radius: 5px; margin-bottom: 10px;">Manual</button>
            </div>
            <div>
                <button onclick="selectAction('EAF')" style="padding: 8px 16px; background-color: #007bff; color: white; border: none; border-radius: 5px;">EAF</button>
            </div>
        </div>
    </div>

        <!-- EAF Modal with PDF Schedule Extractor -->
    <div id="eafModal" style="display:none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; 
    background: rgba(0, 0, 0, 0.5); z-index: 9999; justify-content: center; align-items: center;">
        <div style="background: white; padding: 30px; border-radius: 10px; text-align: center; max-width: 500px; width: 80%; overflow-y: auto;">
            <h2>PDF Schedule Extractor</h2>
            <input type="file" id="pdfUpload" accept="application/pdf" style="margin-bottom: 15px;">
            <div id="schedule" style="margin-top: 20px; padding: 10px; border: 1px solid #ccc; text-align: left;"></div>
            <button id="submitAvailabilityBtn" style="display:none; margin-top: 10px;">Submit Availability</button>
            <button onclick="closeEAFModal()" style="margin-top: 15px; padding: 8px 16px; background-color: #ff5733; color: white; border: none; border-radius: 5px;">Close</button>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.4.120/pdf.min.js"></script>


    <script>
        let isMouseDown = false;
        let activeUser = null;
        let selectedAvailability = [];
        let eventId = new URLSearchParams(window.location.search).get("id");


        async function fetchEventData() {
            if (!eventId) {
                document.body.innerHTML = "<h2>Invalid Event ID</h2>";
                return;
            }
            try {
                const response = await fetch(`/events/${eventId}`);
                if (!response.ok) throw new Error("Failed to fetch event data.");

                const event = await response.json();
                document.getElementById("eventName").innerText = event.eventName;
                generateScheduleGrid(event);  // This will generate the grid dynamically
                loadAvailability();  // Load availability automatically after the grid is generated
            } catch (error) {
                document.body.innerHTML = `<h2>Error loading event: ${error.message}</h2>`;
            }
        }

        async function loadAvailability() {
            try {
                const response = await fetch(`/events/${eventId}`);
                if (!response.ok) throw new Error("Failed to load event data.");

                const eventData = await response.json();
                updateTableWithAvailability(eventData); // Update the grid with availability data
            } catch (error) {
                console.error("Error loading availability:", error);
            }
        }

        function renderParticipantPanel() {
            const participantList = document.getElementById("participantList");
            participantList.innerHTML = "";

            users.forEach(user => {
                const div = document.createElement("div");
                div.className = "bg-blue-100 text-blue-800 rounded px-3 py-1 text-sm";
                div.textContent = user.name;
                participantList.appendChild(div);
            });
        }

        function showTooltip(event, text) {
            let tooltip = document.getElementById("hoverTooltip");
            if (!tooltip) {
                tooltip = document.createElement("div");
                tooltip.id = "hoverTooltip";
                tooltip.style.position = "absolute";
                tooltip.style.padding = "6px 10px";
                tooltip.style.background = "rgba(0, 0, 0, 0.8)";
                tooltip.style.color = "#fff";
                tooltip.style.borderRadius = "4px";
                tooltip.style.pointerEvents = "none";
                tooltip.style.fontSize = "14px";
                tooltip.style.zIndex = "9999";
                document.body.appendChild(tooltip);
            }
            tooltip.innerText = text;
            tooltip.style.display = "block";
            moveTooltip(event);
        }

        function moveTooltip(event) {
            const tooltip = document.getElementById("hoverTooltip");
            if (tooltip) {
                tooltip.style.left = (event.pageX + 10) + "px";
                tooltip.style.top = (event.pageY + 10) + "px";
            }
        }


        function hideTooltip() {
            const tooltip = document.getElementById("hoverTooltip");
            if (tooltip) {
                tooltip.style.display = "none";
            }
        }

        function attachHoverListeners() {
            const timeSlots = document.querySelectorAll(".time-slot");

            timeSlots.forEach(slot => {
                slot.addEventListener("mouseenter", (e) => {
                    const participants = slot.getAttribute("data-participants");
                    if (participants) {
                        showTooltip(e, participants);
                    }
                });

                slot.addEventListener("mousemove", (e) => {
                    moveTooltip(e);
                });

                slot.addEventListener("mouseleave", () => {
                    hideTooltip();
                });
            });
        }


    function updateTableWithAvailability(eventData) {
        // Reset ALL time-slots
        document.querySelectorAll(".time-slot").forEach(td => {
            td.classList.remove("saved", "selected", "disabled");
            td.classList.add("available");
            td.removeAttribute("data-participants");
        });

        // Update participants list
        const participantList = document.getElementById("participantList");
        participantList.innerHTML = "";
        eventData.users.forEach(user => {
            const participantDiv = document.createElement("div");
            participantDiv.className = "flex items-center space-x-2";
            participantDiv.innerHTML = `
                <div class="w-2 h-2 rounded-full bg-green-500"></div>
                <div class="text-gray-800 font-medium">${user.name}</div>
            `;
            participantList.appendChild(participantDiv);
        });

        // Fill in slotMap based on eventData
        const slotMap = {};
        eventData.users.forEach(user => {
            user.availabilities.forEach(slot => {
                const key = `${slot.day}_${slot.time}`;
                if (!slotMap[key]) slotMap[key] = [];
                slotMap[key].push(user.name);
            });
        });

        // Apply .saved class and participant names
        Object.entries(slotMap).forEach(([key, names]) => {
            const [day, time] = key.split("_");
            const td = document.querySelector(`td[data-day="${day}"][data-time="${time}"]`);
            if (td) {
                td.classList.add("saved");
                td.setAttribute("data-participants", names.join(", "));
            }
        });

        attachHoverListeners();
    }
   
        function askUserName() {
            document.getElementById("nameModal").style.display = "flex";
        }

        function submitUserName() {
            const userInput = document.getElementById("userNameInput").value.trim();
            if (!userInput) {
                alert("Please enter your name.");
                return;
            }

            activeUser = userInput;
            document.getElementById("nameModal").style.display = "none";
            document.getElementById("saveButton").classList.remove("hidden");
            document.querySelector(".button-container").classList.remove("hidden");

            // Display the action modal after username submission
            document.getElementById("actionModal").style.display = "flex";
        }

        function selectAction(action) {
            console.log(`User selected: ${action}`);

            // Close the action modal after selection
            document.getElementById("actionModal").style.display = "none";

            // Show the EAF Modal if the user selects EAF
            if (action === 'EAF') {
                document.getElementById("eafModal").style.display = "flex";
            }
        }

        function closeEAFModal() {
            document.getElementById("eafModal").style.display = "none";
        }

        function convertTo24HourFormat(timeStr) {
            const [time, modifier] = timeStr.split(" ");
            let [hours, minutes] = time.split(":").map(Number);
            
            if (modifier === "PM" && hours !== 12) {
                hours += 12;
            } else if (modifier === "AM" && hours === 12) {
                hours = 0;
            }

            return hours;  // Returning hours only, assuming minutes are always ":00"
        }

        function formatTime(hour) {
            const ampm = hour >= 12 ? "PM" : "AM";
            const formattedHour = hour % 12 === 0 ? 12 : hour % 12;
            return `${formattedHour}:00 ${ampm}`;
        }

    function enableSelection() {
        document.querySelectorAll(".time-slot").forEach(td => {
            td.addEventListener("mousedown", () => {
                if (!td.classList.contains("disabled")) {
                    isMouseDown = true;
                    toggleSelection(td);
                }
            });

            td.addEventListener("mouseover", (e) => {
                if (isMouseDown && !td.classList.contains("disabled")) {
                    toggleSelection(td);
                }
            });

            td.addEventListener("mouseup", () => {
                isMouseDown = false;
            });
        });

        document.addEventListener("mouseup", () => isMouseDown = false);
    }

    function generateScheduleGrid(event) {
        const scheduleTable = document.getElementById("scheduleTable");
        scheduleTable.innerHTML = ""; // Clear table before generating new data

        const headers = event.scheduleType === "Days of the Week" ? event.selectedDays : event.selectedDates;
        
        if (!headers || headers.length === 0) {
            console.error("No headers available for schedule grid.");
            return;
        }

        // Convert time range into 24-hour format
        const [startHour, endHour] = event.timeRange.split(" - ").map(convertTo24HourFormat);

        // Create table header
        const thead = document.createElement("thead");
        const headerRow = document.createElement("tr");
        headerRow.innerHTML = `<th>Time</th>` + headers.map(day => `<th>${day}</th>`).join("");
        thead.appendChild(headerRow);
        scheduleTable.appendChild(thead);

        // Create table body
        const tbody = document.createElement("tbody");

        for (let hour = startHour; hour <= endHour; hour++) {
            const row = document.createElement("tr");
            row.innerHTML = `<td>${formatTime(hour)}</td>` + headers.map(day => 
                `<td class="time-slot available" data-day="${day}" data-time="${formatTime(hour)}"></td>` // Set all to available
            ).join("");
            tbody.appendChild(row);
        }

        scheduleTable.appendChild(tbody);

        enableSelection(); // Enable click and drag selection
    }

        function toggleSelection(td) {
            if (!activeUser || td.classList.contains("disabled")) return;

            td.classList.toggle("selected");
            const availability = { day: td.dataset.day, time: td.dataset.time };

            if (td.classList.contains("selected")) {
                selectedAvailability.push(availability);
            } else {
                selectedAvailability = selectedAvailability.filter(a => !(a.day === availability.day && a.time === availability.time));
            }
        }


        function enableGrid() {
            document.querySelectorAll(".time-slot").forEach(td => {
                td.classList.remove("disabled");
            });
        }

        function highlightSelectedSlots() {
            selectedAvailability.forEach(slot => {
                const dayColumn = slot.day; // Day (M, T, W, H, F, S)
                const time = slot.time; // Time range (e.g., 0915-1045)
                
                // Find the corresponding table cell by matching the data-day and data-time attributes
                const td = document.querySelector(`td[data-day="${dayColumn}"][data-time="${time}"]`);
                if (td) {
                    td.classList.add("selected"); // Mark the cell as selected
                }
            });
        }

        function extractSchedule(text, eventDetails) {
            const dayMap = {
                "M": "Monday",
                "T": "Tuesday",
                "W": "Wednesday",
                "H": "Thursday",
                "F": "Friday",
                "S": "Saturday"
            };

            const timeRegex = /(\d{4})-(\d{4})/g;
            const dayRegex = /\b(M|T|W|H|F|S)\b/g;

            function convertTo12Hour(time) {
                let hours = parseInt(time.substring(0, 2));
                let minutes = time.substring(2);
                let period = hours >= 12 ? "PM" : "AM";
                hours = hours % 12 || 12;
                return `${hours}:${minutes} ${period}`;
            }

            function roundDownToHour(time) {
                let hours = parseInt(time.substring(0, 2));
                return `${hours}:00`;
            }

            function roundUpToHour(time) {
                let hours = parseInt(time.substring(0, 2));
                let minutes = parseInt(time.substring(2));
                if (minutes > 0) hours += 1;
                return `${hours}:00`;
            }

            // Extract Days and Times
            let matchedDays = text.match(dayRegex);
            let matchedTimes = text.match(timeRegex);

            if (!matchedDays || !matchedTimes) {
                document.getElementById("schedule").innerHTML = "<p>No valid days and times found.</p>";
                return;
            }

            let availabilities = [];
            for (let i = 0; i < Math.min(matchedDays.length, matchedTimes.length); i++) {
                let day = dayMap[matchedDays[i]];
                let [startRaw, endRaw] = matchedTimes[i].split("-");

                let start = roundDownToHour(startRaw);
                let end = roundUpToHour(endRaw);

                let start12 = convertTo12Hour(start);
                let end12 = convertTo12Hour(end);

                // Check if this availability matches the event schedule
                let eventDayNames = eventDetails.selectedDates.map(dateStr => {
                    let d = new Date(dateStr);
                    return d.toLocaleDateString('en-US', { weekday: 'long' });
                });

                if (eventDayNames.includes(day)) {
                    // Check if the time is within the event's timeRange
                    let [eventStart, eventEnd] = eventDetails.timeRange.split(" - ");

                    // Simple time comparison (in 24h)
                    function timeToMinutes(t) {
                        let [h, m, ampm] = t.match(/(\d+):(\d+) (AM|PM)/).slice(1);
                        h = parseInt(h);
                        m = parseInt(m);
                        if (ampm === "PM" && h !== 12) h += 12;
                        if (ampm === "AM" && h === 12) h = 0;
                        return h * 60 + m;
                    }

                    if (timeToMinutes(start12) >= timeToMinutes(eventStart) &&
                        timeToMinutes(end12) <= timeToMinutes(eventEnd)) {
                        availabilities.push({
                            day: day,
                            time: `${start12} - ${end12}`
                        });
                    }
                }

            }

            // Display extracted valid data
            const scheduleDiv = document.getElementById("schedule");
            if (availabilities.length === 0) {
                scheduleDiv.innerHTML = "<p>No valid availabilities for this event schedule.</p>";
                return;
            }

            let output = "<h3>Valid Schedule</h3><ul>";
            availabilities.forEach(a => {
                output += `<li><strong>${a.day}</strong>: ${a.time}</li>`;
            });
            output += "</ul>";
            scheduleDiv.innerHTML = output;
            // Show the Submit button if we have availabilities
            const submitBtn = document.getElementById("submitAvailabilityBtn");
            submitBtn.style.display = "block";

            // Store availabilities globally or attach to button
            submitBtn.onclick = () => {
            saveAvailabilityToDatabase(availabilities, eventDetails.eventId);
        }
    }

 
        async function saveAvailabilityToDatabase(availabilities, eventId) {
            if (!activeUser) {
                alert("User not set. Please reload and enter your name.");
                return;
            }

            const formattedAvailabilities = [];

            // Convert availabilities like "Monday" + "9:00 AM - 11:00 AM"
            // into hour-by-hour slots so they match the grid's format
            availabilities.forEach(a => {
                const [startTime, endTime] = a.time.split(" - ");
                let startHour = convertTo24HourFormat(startTime);
                let endHour = convertTo24HourFormat(endTime);

                for (let hour = startHour; hour < endHour; hour++) {
                    formattedAvailabilities.push({
                        day: a.day,
                        time: formatTime(hour)
                    });
                }
            });

            try {
                const response = await fetch(`/events/${eventId}/availability`, {
                    method: "POST",
                    headers: {
                        "Content-Type": "application/json",
                    },
                    body: JSON.stringify({
                        name: activeUser,
                        availabilities: formattedAvailabilities
                    }),
                });

                if (!response.ok) throw new Error("Failed to save availability.");

                alert("Availability saved successfully!");
                document.getElementById("eafModal").style.display = "none";
                loadAvailability(); // Refresh the grid with new data
            } catch (error) {
                console.error("Error saving availability:", error);
                alert("There was an error saving your availability.");
            }
        }




        async function saveAvailability() {
            if (!activeUser || selectedAvailability.length === 0) {
                alert("Please select availability before saving.");
                return;
            }

            try {
                const response = await fetch(`/event/${eventId}/submit`, {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({ name: activeUser, availabilities: selectedAvailability }),
                });

                if (!response.ok) throw new Error("Failed to save availability.");

                alert("Availability saved successfully!");

                // Disable further editing of the table

                await loadAvailability(); // Reload availability to show updates
            } catch (error) {
                console.error("Error saving availability:", error);
                alert("Error saving availability. Please try again.");
            }
        }
    
                // Close modal on ESC
        document.addEventListener("keydown", function (e) {
            if (e.key === "Escape") {
                document.getElementById("nameModal").style.display = "none";
            }
        });

        // Close modal on outside click
        document.getElementById("nameModal").addEventListener("click", function (e) {
            if (e.target === this) {
                this.style.display = "none";
            }
        });

        document.getElementById('pdfUpload').addEventListener('change', async function(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = async function() {
                const typedArray = new Uint8Array(this.result);
                const pdf = await pdfjsLib.getDocument(typedArray).promise;
                
                let textContent = '';
                for (let i = 1; i <= pdf.numPages; i++) {
                    const page = await pdf.getPage(i);
                    const text = await page.getTextContent();
                    textContent += text.items.map(item => item.str).join(" ") + "\n";
                }

                // Extract and display the schedule without creating a new table
                extractSchedule(textContent, eventDetails);
            };
            reader.readAsArrayBuffer(file);
        });

        document.addEventListener("mousedown", () => isMouseDown = true);
        document.addEventListener("mouseup", () => isMouseDown = false);
        window.onload = fetchEventData;

        setInterval(loadAvailability, 5000); // Refresh availability every 5 seconds
        document.getElementById("scheduleTable").addEventListener("mouseleave", () => {
            document.getElementById("participantNames").innerHTML = "";
        });
    </script>
    
</body>
</html>
